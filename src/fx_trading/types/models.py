"""Core data models and types for the FX trading system."""

from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional
from uuid import UUID, uuid4

import pandas as pd


def get_contract_size(symbol: str) -> float:
    """
    Get contract size for a symbol.

    Returns the number of units per standard lot:
    - Forex pairs: 100,000 units (e.g., 100,000 EUR for EURUSD)
    - Gold (XAUUSD): 100 troy ounces
    - Silver (XAGUSD): 5,000 troy ounces
    - Oil (XTIUSD/USOIL): 1,000 barrels

    Args:
        symbol: Trading symbol

    Returns:
        Contract size (units per lot)
    """
    symbol_upper = symbol.upper()

    # Gold
    if "XAU" in symbol_upper or "GOLD" in symbol_upper:
        return 100.0

    # Silver
    if "XAG" in symbol_upper or "SILVER" in symbol_upper:
        return 5000.0

    # Oil
    if "XTI" in symbol_upper or "USOIL" in symbol_upper or "WTI" in symbol_upper:
        return 1000.0

    # Brent Oil
    if "XBR" in symbol_upper or "UKOIL" in symbol_upper or "BRENT" in symbol_upper:
        return 1000.0

    # Standard forex pairs
    return 100000.0


class Side(str, Enum):
    """Order/position side."""

    LONG = "LONG"
    SHORT = "SHORT"
    FLAT = "FLAT"  # No position


class OrderType(str, Enum):
    """Order type enumeration."""

    MARKET = "MARKET"
    STOP_LOSS = "STOP_LOSS"
    TAKE_PROFIT = "TAKE_PROFIT"
    LIMIT = "LIMIT"


class OrderStatus(str, Enum):
    """Order status enumeration."""

    PENDING = "PENDING"
    FILLED = "FILLED"
    PARTIALLY_FILLED = "PARTIALLY_FILLED"
    CANCELLED = "CANCELLED"
    REJECTED = "REJECTED"
    EXPIRED = "EXPIRED"


class PositionStatus(str, Enum):
    """Position status enumeration."""

    OPEN = "OPEN"
    CLOSED = "CLOSED"


@dataclass
class PriceData:
    """
    Price data at a specific point in time.

    Contains bid/ask for realistic execution modeling.
    """

    timestamp: datetime
    symbol: str
    bid: float
    ask: float
    mid: float = field(init=False)
    spread: float = field(init=False)
    open: Optional[float] = None
    high: Optional[float] = None
    low: Optional[float] = None
    close: Optional[float] = None
    volume: Optional[float] = None

    def __post_init__(self) -> None:
        """Calculate derived fields."""
        self.mid = (self.bid + self.ask) / 2
        self.spread = self.ask - self.bid

    @property
    def spread_pips(self) -> float:
        """Return spread in pips based on symbol type."""
        if "XAU" in self.symbol or "GOLD" in self.symbol.upper():
            # Gold: 2 decimal places, pip = $0.01
            return self.spread * 100
        elif "JPY" in self.symbol:
            # JPY pairs: 2 decimal places
            return self.spread * 100
        else:
            # Standard forex: 4 decimal places
            return self.spread * 10000

    def is_stale(self, current_time: datetime, max_age_seconds: float) -> bool:
        """Check if price data is stale."""
        # Handle timezone-aware vs naive comparison
        ts = self.timestamp
        ct = current_time

        # If one is tz-aware and other is tz-naive, make both naive (assume UTC)
        if hasattr(ts, 'tzinfo') and ts.tzinfo is not None:
            if not hasattr(ct, 'tzinfo') or ct.tzinfo is None:
                # ts is aware, ct is naive - convert ts to naive
                ts = ts.replace(tzinfo=None) if hasattr(ts, 'replace') else ts.tz_localize(None)
        elif hasattr(ct, 'tzinfo') and ct.tzinfo is not None:
            # ct is aware, ts is naive - convert ct to naive
            ct = ct.replace(tzinfo=None)

        # Handle pandas Timestamp
        if hasattr(ts, 'to_pydatetime'):
            ts = ts.to_pydatetime().replace(tzinfo=None)
        if hasattr(ct, 'to_pydatetime'):
            ct = ct.to_pydatetime().replace(tzinfo=None)

        age = (ct - ts).total_seconds()
        return age > max_age_seconds


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Represents the desired position or action.
    """

    timestamp: datetime
    symbol: str
    side: Side
    strength: float = 1.0  # Signal strength/confidence [0, 1]
    stop_loss: Optional[float] = None  # Absolute price for SL
    take_profit: Optional[float] = None  # Absolute price for TP
    time_exit_bars: Optional[int] = None  # Exit after N bars
    metadata: dict = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Validate signal."""
        if not 0 <= self.strength <= 1:
            raise ValueError(f"Signal strength must be in [0, 1], got {self.strength}")


@dataclass
class Order:
    """
    Order to be executed.

    Contains all information needed to execute a trade.
    """

    id: UUID = field(default_factory=uuid4)
    timestamp: datetime = field(default_factory=datetime.utcnow)
    symbol: str = ""
    side: Side = Side.FLAT
    order_type: OrderType = OrderType.MARKET
    size: float = 0.0  # Lot size
    price: Optional[float] = None  # Limit/stop price
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    time_in_force_bars: Optional[int] = None
    status: OrderStatus = OrderStatus.PENDING
    parent_position_id: Optional[UUID] = None  # For SL/TP orders
    idempotency_key: str = ""  # For preventing double execution
    metadata: dict = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Generate idempotency key if not provided."""
        if not self.idempotency_key:
            self.idempotency_key = f"{self.symbol}_{self.side.value}_{self.timestamp.isoformat()}_{self.id}"


@dataclass
class Fill:
    """
    Record of an executed order fill.

    Contains actual execution details.
    """

    id: UUID = field(default_factory=uuid4)
    order_id: UUID = field(default_factory=uuid4)
    timestamp: datetime = field(default_factory=datetime.utcnow)
    symbol: str = ""
    side: Side = Side.FLAT
    size: float = 0.0
    fill_price: float = 0.0
    commission: float = 0.0
    slippage: float = 0.0  # In price terms
    slippage_pips: float = 0.0
    is_entry: bool = True
    metadata: dict = field(default_factory=dict)


@dataclass
class Position:
    """
    Open trading position.

    Tracks an active position with all relevant state.
    """

    id: UUID = field(default_factory=uuid4)
    symbol: str = ""
    side: Side = Side.FLAT
    size: float = 0.0
    entry_price: float = 0.0
    entry_time: datetime = field(default_factory=datetime.utcnow)
    current_price: float = 0.0
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    entry_bar_index: int = 0
    time_exit_bars: Optional[int] = None
    status: PositionStatus = PositionStatus.OPEN
    entry_commission: float = 0.0
    entry_slippage: float = 0.0
    unrealized_pnl: float = 0.0
    metadata: dict = field(default_factory=dict)

    def update_pnl(self, bid: float, ask: float) -> float:
        """
        Update and return unrealized PnL.

        Uses bid for long exits (sell), ask for short exits (buy to cover).
        Contract size is determined by symbol type (forex=100k, gold=100, etc).
        """
        contract_size = get_contract_size(self.symbol)

        if self.side == Side.LONG:
            exit_price = bid
            self.unrealized_pnl = (exit_price - self.entry_price) * self.size * contract_size
        elif self.side == Side.SHORT:
            exit_price = ask
            self.unrealized_pnl = (self.entry_price - exit_price) * self.size * contract_size
        else:
            self.unrealized_pnl = 0.0

        self.current_price = exit_price
        return self.unrealized_pnl

    def check_stop_loss(self, bid: float, ask: float) -> bool:
        """Check if stop loss is triggered."""
        if self.stop_loss is None:
            return False

        if self.side == Side.LONG:
            return bid <= self.stop_loss
        elif self.side == Side.SHORT:
            return ask >= self.stop_loss
        return False

    def check_take_profit(self, bid: float, ask: float) -> bool:
        """Check if take profit is triggered."""
        if self.take_profit is None:
            return False

        if self.side == Side.LONG:
            return bid >= self.take_profit
        elif self.side == Side.SHORT:
            return ask <= self.take_profit
        return False

    def check_time_exit(self, current_bar_index: int) -> bool:
        """Check if time-based exit is triggered."""
        if self.time_exit_bars is None:
            return False

        bars_held = current_bar_index - self.entry_bar_index
        return bars_held >= self.time_exit_bars


@dataclass
class Trade:
    """
    Completed trade record (round trip).

    Contains full trade history from entry to exit.
    """

    id: UUID = field(default_factory=uuid4)
    symbol: str = ""
    side: Side = Side.FLAT
    size: float = 0.0
    entry_time: datetime = field(default_factory=datetime.utcnow)
    exit_time: Optional[datetime] = None
    entry_price: float = 0.0
    exit_price: float = 0.0
    entry_commission: float = 0.0
    exit_commission: float = 0.0
    total_commission: float = field(init=False, default=0.0)
    entry_slippage: float = 0.0
    exit_slippage: float = 0.0
    total_slippage: float = field(init=False, default=0.0)
    gross_pnl: float = 0.0  # Before costs
    net_pnl: float = 0.0  # After costs
    r_multiple: Optional[float] = None  # PnL / initial risk
    exit_reason: str = ""  # STOP_LOSS, TAKE_PROFIT, TIME_EXIT, SIGNAL, RISK_KILL
    bars_held: int = 0
    metadata: dict = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Calculate derived fields."""
        self.total_commission = self.entry_commission + self.exit_commission
        self.total_slippage = self.entry_slippage + self.exit_slippage

    def calculate_pnl(self) -> None:
        """Calculate gross and net PnL using symbol-specific contract size."""
        contract_size = get_contract_size(self.symbol)

        if self.side == Side.LONG:
            self.gross_pnl = (self.exit_price - self.entry_price) * self.size * contract_size
        elif self.side == Side.SHORT:
            self.gross_pnl = (self.entry_price - self.exit_price) * self.size * contract_size

        self.net_pnl = self.gross_pnl - self.total_commission - self.total_slippage


@dataclass
class AccountState:
    """
    Current account state.

    Tracks all balance and margin information.
    """

    timestamp: datetime = field(default_factory=datetime.utcnow)
    balance: float = 10000.0  # Cash balance
    equity: float = field(init=False)
    unrealized_pnl: float = 0.0
    realized_pnl: float = 0.0
    margin_used: float = 0.0
    margin_available: float = field(init=False)
    leverage: float = 1.0
    daily_pnl: float = 0.0
    peak_equity: float = 10000.0
    drawdown: float = 0.0
    drawdown_pct: float = 0.0

    def __post_init__(self) -> None:
        """Calculate derived fields."""
        self.equity = self.balance + self.unrealized_pnl
        self.margin_available = self.equity - self.margin_used

    def update(self, unrealized_pnl: float, margin_used: float) -> None:
        """Update account state with current values."""
        self.unrealized_pnl = unrealized_pnl
        self.margin_used = margin_used
        self.equity = self.balance + self.unrealized_pnl
        self.margin_available = self.equity - self.margin_used

        # Update peak and drawdown
        if self.equity > self.peak_equity:
            self.peak_equity = self.equity

        self.drawdown = self.peak_equity - self.equity
        self.drawdown_pct = (self.drawdown / self.peak_equity) * 100 if self.peak_equity > 0 else 0.0


@dataclass
class RiskCheckResult:
    """Result of a single risk check."""

    check_name: str
    passed: bool
    reason: str = ""
    value: Optional[float] = None
    threshold: Optional[float] = None


@dataclass
class RiskDecision:
    """
    Aggregated risk decision from all checks.

    Contains detailed breakdown of what passed/failed.
    """

    timestamp: datetime = field(default_factory=datetime.utcnow)
    symbol: str = ""
    approved: bool = True
    checks: list[RiskCheckResult] = field(default_factory=list)
    adjusted_size: Optional[float] = None  # Size after risk adjustment
    original_size: Optional[float] = None
    kill_switch_active: bool = False

    def add_check(self, result: RiskCheckResult) -> None:
        """Add a check result and update approval status."""
        self.checks.append(result)
        if not result.passed:
            self.approved = False

    def get_rejection_reasons(self) -> list[str]:
        """Get list of all rejection reasons."""
        return [c.reason for c in self.checks if not c.passed]

    def to_dict(self) -> dict:
        """Convert to dictionary for logging."""
        return {
            "timestamp": self.timestamp.isoformat(),
            "symbol": self.symbol,
            "approved": self.approved,
            "kill_switch_active": self.kill_switch_active,
            "adjusted_size": self.adjusted_size,
            "original_size": self.original_size,
            "checks": [
                {
                    "name": c.check_name,
                    "passed": c.passed,
                    "reason": c.reason,
                    "value": c.value,
                    "threshold": c.threshold,
                }
                for c in self.checks
            ],
            "rejection_reasons": self.get_rejection_reasons(),
        }


@dataclass
class PortfolioSnapshot:
    """Point-in-time snapshot of portfolio state."""

    timestamp: datetime
    equity: float
    balance: float
    unrealized_pnl: float
    realized_pnl: float
    drawdown_pct: float
    num_positions: int
    total_exposure: float
    margin_used: float


@dataclass
class DailySummary:
    """Daily trading summary."""

    date: datetime
    starting_equity: float
    ending_equity: float
    daily_return: float
    daily_return_pct: float
    num_trades: int
    winning_trades: int
    losing_trades: int
    gross_pnl: float
    net_pnl: float
    total_commission: float
    total_slippage: float
    max_drawdown_pct: float
    sharpe_ratio: Optional[float] = None

    @property
    def win_rate(self) -> float:
        """Calculate win rate."""
        if self.num_trades == 0:
            return 0.0
        return self.winning_trades / self.num_trades
